<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis的内存淘汰策略</title>
    <link href="/posts/2599068157.html"/>
    <url>/posts/2599068157.html</url>
    
    <content type="html"><![CDATA[<h2 id="Redis的内存设置"><a href="#Redis的内存设置" class="headerlink" title="Redis的内存设置"></a>Redis的内存设置</h2><p>Redis的内存及缓存策略，可以通过redis的配置文件<code>redis.conf</code>设置，也可以在运行的时候通过指令动态设置。</p><h3 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h3><p>内存大小通过设置参数 <code>maxmemory</code>  内存策略通过设置参数 <code>maxmemory-policy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs redis">maxmemory 256 <br>maxmemory-policy allkeys-lru<br></code></pre></td></tr></table></figure><h3 id="动态设置"><a href="#动态设置" class="headerlink" title="动态设置"></a>动态设置</h3><p>通过 <code>CONFIG-SET</code>指令进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs redis">CONFIG SET maxmemory 256 <br>CONFIG SET maxmemory-policy allkeys-lru<br></code></pre></td></tr></table></figure><h3 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h3><p>当<code>Redis</code>的内存达到<code>maxmemory</code>，<code>Redis</code>会采用<code>maxmemory-policy</code>设置的淘汰策略，去淘汰数据。<br><code>Redis</code>提供了8种淘汰策略分别是</p><ul><li><code>noeviction</code> 达到最大内存限制时，不删除任何数据，直接返回错误。</li><li><code>allkeys-lru</code> 基于最近最少使用(LRU)算法，删除<code>所有key</code>中最近最少使用的key。</li><li><code>allkeys-lfu</code>基于最近最不常用(LFU)算法，删除<code>所有key</code>中最近最不常用的key。</li><li><code>allkeys-random</code> 随机删除<code>所有key</code>中最近最不常用的key。</li><li><code>volatile-lru</code> 基于最近最少使用(LRU)算法，删除<code>已设置过期时间的key</code>中最近最少使用的key。</li><li><code>volatile-lfu</code>基于最近最不常用(LFU)算法，删除<code>已设置过期时间的key</code>中最近最不常用的key。</li><li><code>volatile-random</code> 随机删除<code>已设置过期时间的key</code>中最近最不常用的key。</li><li><code>volatile-ttl</code> 删除<code>已设置过期时间的key</code>中最早过期的key</li></ul><p>按照淘汰范围来看，内存淘汰策略分为</p><ul><li>不淘汰数据</li><li>从所有的key中进行淘汰</li><li>只从设置了过期时间的key中进行淘汰</li></ul><p>淘汰算法又分为</p><ul><li><code>Random</code></li><li><code>LRU</code></li><li>&#96;LFU</li></ul><h4 id="Redis-LRU的实现（近似LRU）"><a href="#Redis-LRU的实现（近似LRU）" class="headerlink" title="Redis LRU的实现（近似LRU）"></a>Redis LRU的实现（近似LRU）</h4><p>常见的LRU实现，是通过维护一个双向链表，当访问节点时，将节点移动到链表的头部。这样节点就会按照最近访问的时间顺序进行排序，当需要移除节点时，直接移除链表的尾节点即可。[[LRU Java实现]]</p><p><img src="https://zhangjunxian.oss-cn-guangzhou.aliyuncs.com/img/20240919210023.png" alt="image.png"></p><p>而对于Redis来说，采用这样的方式来实现LRU会有以下问题。</p><ul><li>维护这样的双向链表花销大</li><li>因为需要额外存储双向链表的指针，所以内存占用大</li></ul><p>所以Redis采用的是<code>近似LRU</code>算法，每次访问key时，通过其存储结构中的<code>lru</code>字段去存储key本次访问的时间，当需要淘汰key时，将会从全部数据中进行<code>随机抽样</code>，然后<code>移除样本</code>中上次访问时间最早的key。</p><p>优点如下：</p><ul><li>当需要淘汰key时，才进行抽样，所以不需要维护双向链表，避免了额外的内存开销。</li><li>访问时只需要记录访问时间，不需要操作链表节点，避免了额外的性能开销</li></ul><p>显然抽样的样本数量越多，LRU淘汰的key越准确，但是抽取的样本数量越多带来的花销也更大。<br>我们可以通过<code>maxmemory-samples</code>参数来配置采样数量（默认为5）。</p><p>使用LRU淘汰策略可能会引发<code>缓存污染问题</code> ，指的是系统低频率的进行批量查询，大量数据被放入缓存中，导致热点数据可能误淘汰，从而导致<code>缓存污染</code></p><h4 id="Redis-LFU的实现（近似LFU）"><a href="#Redis-LFU的实现（近似LFU）" class="headerlink" title="Redis LFU的实现（近似LFU）"></a>Redis LFU的实现（近似LFU）</h4><p>同样的Redis的LFU算法也是通过随机抽样的方式来实现，只不过移除样本的是参考的不再是访问时间，而是访问频率，优先淘汰样本中访问频率最低的key。</p><h5 id="访问频率的计算"><a href="#访问频率的计算" class="headerlink" title="访问频率的计算"></a>访问频率的计算</h5><p>Redis没有引入新的数据结构去实现LFU，而是将LRU中使用到的<code>lru</code>字段进行拆分</p><ul><li>高位的16bits用于存储访问时间戳，并且是以分钟为单位的时间戳</li><li>低位的8bits，用于存储热度值(counter)，也就是访问频率。</li></ul><p>当我们每次访问key时，counter的值会基于时间衰减机制以及概率机制进行动态改变。</p><blockquote><p>这种基于概率，使用极小内存对大量事件进行计数的计数器被称为莫里斯计数器，它是一种概率计数法的实现。</p></blockquote><h6 id="时间衰减机制"><a href="#时间衰减机制" class="headerlink" title="时间衰减机制"></a>时间衰减机制</h6><p>通过计算（这一次的访问时间 - 上一次的访问时间）&#x2F; 衰减周期，从而计算出counter的衰减值，<br><code>counter = counter - 衰减值</code>。<br>在Redis中，我们可以通过参数<code>lfu_decay_time</code>(默认值1)进行配置。</p><h5 id="概率递增机制"><a href="#概率递增机制" class="headerlink" title="概率递增机制"></a>概率递增机制</h5><p>概率递增算法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LFU_INIT_VAL 5</span><br> <br><span class="hljs-comment">/* Logarithmically increment a counter. The greater is the current counter value</span><br><span class="hljs-comment"> * the less likely is that it gets really implemented. Saturate it at 255. */</span><br><span class="hljs-function"><span class="hljs-type">uint8_t</span> <span class="hljs-title">LFULogIncr</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> counter)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (counter == <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">255</span>;<br>  <span class="hljs-type">double</span> r = (<span class="hljs-type">double</span>)<span class="hljs-built_in">rand</span>()/RAND_MAX;<br>  <span class="hljs-type">double</span> baseval = counter - LFU_INIT_VAL;<br>  <span class="hljs-keyword">if</span> (baseval &lt; <span class="hljs-number">0</span>) baseval = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">double</span> p = <span class="hljs-number">1.0</span>/(baseval*server.lfu_log_factor+<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (r &lt; p) counter++;<br>  <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当<code>counter</code>等于255时，将不会再递增</li><li>当<code>counter</code>的值小于初始值5的时候，将百分百概率进行递增。</li><li>当<code>counter</code>的值大于初始值5的时候，先计算两者的差值，然后作为分母参与递增概率的计算，当递增概率大于随机概率时，才会递增</li><li>随着<code>counter</code>的增大，递增的概率会原来越小，会出现多次访问，<code>counter</code>也不会递增的情况出现。</li></ul><p>我们可以通过配置递增衰减因子<code>lfu_log_factor</code>(默认值10),来调整递增概率的计算。<br>通过时间衰减机制以及概率递增机制计算访问频率，解决了只参考访问次数，忽略访问时间带来的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>#Redis</tag>
      
      <tag>#内存淘汰策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分搜索及其边界查找</title>
    <link href="/posts/4081649024.html"/>
    <url>/posts/4081649024.html</url>
    
    <content type="html"><![CDATA[<p>时隔接近两个月，第二篇vlog</p><p>时隔两年的，第一次更新，之前的有点小问题，改了一下，引入了循环不变量的概念。</p><span id="more"></span><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a><strong>算法介绍</strong></h2><p>是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特</p><p>定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表</p><p>找不到。这种搜索算法每一次比较都使搜索范围缩小一半</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a><strong>算法步骤</strong></h2><ol><li><p>首先确定整个查找区间的中间位置 mid &#x3D; （ left + right ）&#x2F;2 。</p></li><li><p>用待查关键字值与中间位置的关键字值进行比较， 若相等，则查找成功　 若大于，则在后（右）半个区域继续进行折半查找　 若小于，则在前</p><p> （左）半个区域继续进行折半查找。</p></li><li><p>对确定的缩小区域再按折半公式，重复上述步骤。最后，得到结果：要么查找成功， 要么查找失败。折半查找的存储结构采用一维数组存</p></li></ol><p><img src="http://zhangjunxian.oss-cn-guangzhou.aliyuncs.com/img/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.gif" alt="二分查找"></p><h2 id="两种模板"><a href="#两种模板" class="headerlink" title="两种模板"></a>两种模板</h2><p>二分查找常见的有两种模板</p><ul><li><p>左闭右开区间 指的是</p><p>初始条件为 ：<strong>left &#x3D; 0  、right &#x3D; n</strong>  </p><p>结束条件为 ：<strong>l  &lt;  r</strong></p></li><li><p>左闭右闭区间 指的是</p><p>初始条件为： <strong>left &#x3D; 0 、right &#x3D; n-1</strong> </p><p>结束条件为 ：<strong>l &lt;&#x3D;r</strong></p></li></ul><h3 id="第一种模板"><a href="#第一种模板" class="headerlink" title="第一种模板"></a><strong>第一种模板</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">        左闭右开 [left, right) 结束循环条件为 l &lt; r</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = arr.length, m;<br><br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        m = (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[m] == target)&#123;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[m] &gt; target)&#123;<br>            r = m;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = m + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="第二种模板"><a href="#第二种模板" class="headerlink" title="第二种模板"></a>第二种模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    左闭右开 [left, right] 结束循环条件为 l &lt;= r</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = arr.length - <span class="hljs-number">1</span>, m;<br><br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        m = (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[m] == target)&#123;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[m] &gt; target)&#123;<br>            r = m - <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = m + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何理解这两种写法"><a href="#如何理解这两种写法" class="headerlink" title="如何理解这两种写法"></a>如何理解这两种写法</h3><p>对于第一种写法实际上是 左闭右开区间，实际上指的是在二分数组的时候将数组划分为<br><code>[left,mid)</code> 和 <code>[mid, right)</code></p><p>所以说初始条件设置为 <code>left = 0</code>, <code>right = n</code>  结束条件为 l &lt; r  因为 l &#x3D;&#x3D; r 是 说明此时所有区间已经搜索完了</p><p>因此 当 <code>arr[mid]  &gt; target</code> 时，说明此时 <code>target</code> 在  <code>[left,mid)</code> 区间中 所以 <code>right = mid</code></p><p>同理 当 <code>arr[mid] &lt; target</code> 时，说明此时 <code>target</code> 在 <code>[mid, right)</code> 区间中，所以 <code>left = mid + 1</code></p><p>对于第二种写法，同理。</p><h2 id="二分查找的拓展"><a href="#二分查找的拓展" class="headerlink" title="二分查找的拓展"></a>二分查找的拓展</h2><h3 id="第一种模板-1"><a href="#第一种模板-1" class="headerlink" title="第一种模板"></a>第一种模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">采用左闭右闭区间[left,right)，结束条件为 l &lt; r</span><br><span class="hljs-comment">寻找第一个大于等于target的值，</span><br><span class="hljs-comment">[1,2,5,5,5,7] target = 5返回第一个5的index</span><br><span class="hljs-comment">[1,2,5,7,7,8] target = 6 返回第一个7的index</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lower_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = arr.length, m;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>       m = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[m] &lt; target) l = m + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = m;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">采用左闭右开区间[left,right)，结束条件为 l &lt; r</span><br><span class="hljs-comment">寻找第一个大于target的值，</span><br><span class="hljs-comment">[1,2,5,5,5,7] target = 5返回最后一个7的index</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">upper_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = arr.length, m;<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>m = l + (r - l) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(arr[m] &lt;= target) l = m + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> r = m;<br>&#125;<br><span class="hljs-keyword">return</span>  l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二种模板-1"><a href="#第二种模板-1" class="headerlink" title="第二种模板"></a>第二种模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">采用左闭右闭区间[left,right],结束条件为 l &lt;= r</span><br><span class="hljs-comment">寻找第一个大于等于target的值</span><br><span class="hljs-comment">[1,2,5,5,5,7] target = 5返回第一个5的index</span><br><span class="hljs-comment">[1,2,5,7,7,8] target = 6 返回第一个7的index</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lower_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = arr.length - <span class="hljs-number">1</span>, m;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>m = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[m] &lt; target) l = m + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = m - <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> l; <span class="hljs-comment">// return r + 1</span><br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">采用左闭右闭区间[left,right]，结束条件为 l &lt;= r</span><br><span class="hljs-comment">寻找第一个大于target的值，</span><br><span class="hljs-comment">[1,2,5,5,5,7] target = 5返回最后一个7的index</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">upper_bound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = arr.length - <span class="hljs-number">1</span>, m;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        m = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[m] &lt;= target) l = m + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = m - <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> l; <span class="hljs-comment">// return r + 1    </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h3><p>从<strong>循环不变式</strong>的角度出发，就能够清晰的明白二分的原理。</p><blockquote><p>循环不变式是在循环体的每次执行前后均为真的谓词。循环不变式体现了循环程序中循环变量的变化规律 。</p><p>条件：循环不等式，在初始、迭代、终止都恒为真</p></blockquote><p>对于lower_bound,它想查找目标是<strong>第一个大于等于target的元素</strong>,这里假如target为4，那么结果应该就是箭头所指的元素。<br><img src="https://zhangjunxian.oss-cn-guangzhou.aliyuncs.com/img/20240604164923.png" alt="image.png"><br><strong>定义循环不变式</strong>：<strong>l左边的元素是恒小于target，r及r右边的元素是恒大于等于target</strong><br><strong>定义初始值</strong>：<code>l = 0, r = n</code>，满足循环不变式，此时循环不变式覆盖的数组的范围最小。<br><strong>终止条件</strong>：<code>l &lt; r</code>, 即终止时，l &#x3D;&#x3D; r，此时满足循环不变式，l和r所指向的位置就是我们要找的目标。</p><p>当 <code>arr[m] &lt; target</code> 为 <code>true</code>时，我们能够确认的是<strong>左区域是小于target，因此 <code>l = m + 1</code><strong>。<br>当 <code>arr[m] &gt;= target</code>为<code>true</code>时，我们能够确认的是</strong>右区域是大于等于target, 因此 <code>r = m</code></strong><br>当 <code>l == r</code>时，此时循环结束，<code>l</code> 和 <code>r</code> 指向的就是我们要的结果。</p><p><img src="https://zhangjunxian.oss-cn-guangzhou.aliyuncs.com/img/20240604221559.png" alt="image.png"></p><p>我们可以将这个过程理解为<br>根据查找目标，设定<strong>循环不变式</strong>，在二分的过程中，不断扩大满足循环不变式条件的范围，直至将所有数据范围覆盖达到终止。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
